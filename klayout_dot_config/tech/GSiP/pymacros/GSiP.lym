<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
from SiEPIC.utils import get_technology

class Waveguide(pya.PCellDeclarationHelper):

  def __init__(self):
    # Important: initialize the super class
    super(Waveguide, self).__init__()
    # declare the parameters
    TECHNOLOGY = get_technology()
    self.param("path", self.TypeShape, "Path", default = pya.Path([pya.Point(0,0), pya.Point(10,0), pya.Point(10,10)], 0.5))
    self.param("radius", self.TypeDouble, "Radius", default = 5)
    self.param("width", self.TypeDouble, "Width", default = 0.5)
    self.param("adiab", self.TypeBoolean, "Adiabatic", default = False)
    self.param("bezier", self.TypeDouble, "Bezier Parameter", default = 0.35)
    self.param("layers", self.TypeList, "Layers", default = [TECHNOLOGY['Si']])
    self.param("widths", self.TypeList, "Widths", default =  [0.5])
    self.param("offsets", self.TypeList, "Offsets", default = [0])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Waveguide_%s" % self.path
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return shape.is_path()

  def transformation_from_shape(self, layout, shape, layer):
    return pya.Trans(pya.Trans.R0,0,0)

  def parameters_from_shape(self, layout, shape, layer):
    self._param_values = []
    for pd in self._param_decls:
      self._param_values.append(pd.default)
    return self._param_values
        
  def produce_impl(self):

    from SiEPIC.utils import arc, arc_bezier, angle_vector, angle_b_vectors, inner_angle_b_vectors
    from math import cos, sin, pi, sqrt
    TECHNOLOGY = get_technology()
    
    dbu = self.layout.dbu
    path = self.path*(1/dbu)
    if not (len(self.layers)==len(self.widths) and len(self.layers)==len(self.offsets) and len(self.offsets)==len(self.widths)):
      raise Exception("There must be an equal number of layers, widths and offsets")
    path.remove_colinear_points()
    for i in range(0, len(self.layers)):
      
      if isinstance(self.layers[i], str):
        layer = self.layers[i].split('/')
        layer = self.layout.layer(pya.LayerInfo(int(layer[0]), int(layer[1])))
      else:
        layer = self.layout.layer(self.layers[i])

      width = float(self.widths[i])/dbu
      offset = float(self.offsets[i])/dbu
      #radius = self.radius/dbu + offset
      
      tpath = path.translate_from_center(offset)
      
      pts = tpath.get_points()
      wg_pts = [pts[0]]
      for i in range(1,len(pts)-1):
        turn = ((angle_b_vectors(pts[i]-pts[i-1],pts[i+1]-pts[i])+90)%360-90)/90
        radius = (self.radius/dbu + offset) if turn &gt; 0 else (self.radius/dbu - offset)

        pt_radius = radius
        
        dis = pts[i].distance(pts[i-1])
        if (i==1 and dis &lt; pt_radius):
          pt_radius = dis - TECHNOLOGY['dbu']
        elif (dis &lt; 2*pt_radius):
          pt_radius = dis/2
        
        dis = pts[i].distance(pts[i+1])
        if (i==len(pts)-2 and dis &lt; pt_radius):
          pt_radius = dis - TECHNOLOGY['dbu']
        elif (dis &lt; 2*pt_radius):
          pt_radius = dis/2

        if(self.adiab):
          arc_pts = [pya.Point(-pt_radius, pt_radius) + pt for pt in arc_bezier(pt_radius, 270, 270 + inner_angle_b_vectors(pts[i-1]-pts[i], pts[i+1]-pts[i]), self.bezier)]
        else:
          arc_pts = [pya.Point(-pt_radius, pt_radius) + pt for pt in arc(pt_radius, 270, 270 + inner_angle_b_vectors(pts[i-1]-pts[i], pts[i+1]-pts[i]))]
        angle = angle_vector(pts[i]-pts[i-1])/90
        
        wg_pts += pya.Path(arc_pts, width).transformed(pya.Trans(angle, turn &lt; 0, pts[i])).get_points()

      wg_pts.append(pts[-1])
      self.cell.shapes(layer).insert(pya.Path(wg_pts, width).simple_polygon())

    pts = path.get_points()
    LayerPinRecN = self.layout.layer(TECHNOLOGY['PinRec'])
    
    t = pya.Trans(angle_vector(pts[0]-pts[1])/90, False, pts[0])
    self.cell.shapes(LayerPinRecN).insert(pya.Path([pya.Point(-100, 0), pya.Point(100, 0)], self.width/dbu).transformed(t))
    self.cell.shapes(LayerPinRecN).insert(pya.Text("pin1", t)).text_size = 0.4/dbu
    
    t = pya.Trans(angle_vector(pts[-1]-pts[-2])/90, False, pts[-1])
    self.cell.shapes(LayerPinRecN).insert(pya.Path([pya.Point(-100, 0), pya.Point(100, 0)], self.width/dbu).transformed(t))
    self.cell.shapes(LayerPinRecN).insert(pya.Text("pin2", t)).text_size = 0.4/dbu

    self.cell.shapes(self.layout.guiding_shape_layer()).insert(pya.Path(path.get_points(), path.width))
    
class Ring(pya.PCellDeclarationHelper):
  def __init__(self):
    # Important: initialize the super class
    super(Ring, self).__init__()
    # declare the parameters
    TECHNOLOGY = get_technology()
    self.param("width", self.TypeDouble, "Width", default = 0.5)
    self.param("radius", self.TypeDouble, "Radius", default = 5)
    self.param("layer", self.TypeLayer, "Layer", default = TECHNOLOGY['Si'])
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Ring_%s" % self.radius
  
  def coerce_parameters_impl(self):
    pass
        
  def produce_impl(self):
    from SiEPIC.utils import arc
    
    dbu = self.layout.dbu
    
    layer = self.layout.layer(self.layer)
    radius = self.radius/dbu
    width = self.width/dbu
    
    poly = pya.Polygon(arc(radius+width/2, 0, 360))
    hole = pya.Polygon(arc(radius-width/2, 0, 360))
    poly.insert_hole(hole.get_points())
    self.cell.shapes(layer).insert(poly)

class LumericalINTERCONNECT_Laser(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the LumericalINTERCONNECT Optical Network Analyzer.
  This configures the swept tunable laser
  
  Ultimately want to generate Spice output such as:
  
  .ona input_unit=wavelength input_parameter=center_and_range center=1550e-9
  + range=100e-9 start=3 stop=4 number_of_points=1000 orthogonal_identifier=1
  + label=TE peak_analysis=disable number_of_peaks=8 peak_at_maximum=9
  + peak_threshold=0 peak_excursion=11 pit_excursion=12 fwhm_excursion=13
  + minimum_loss=14 sensitivity=-200 analysis_type=scattering_data
  + multithreading=automatic number_of_threads=1 input(1)=X_GC1,opt_fiber
  + output=X_GC2,opt_fiber

  
  """
  def __init__(self):
    # Important: initialize the super class
    super(LumericalINTERCONNECT_Laser, self).__init__()
    # declare the parameters
    self.param("wavelength_start", self.TypeDouble, "Start Wavelength (nm)", default = 1500)
    self.param("wavelength_stop", self.TypeDouble, "Stop Wavelength (nm)", default = 1600)
    self.param("npoints", self.TypeInt, "Number of points", default = 2000)     
    self.param("orthogonal_identifier", self.TypeInt, "Orthogonal identifier (1=TE, 2=TM)", default = 1)     
    self.param("ignoreOpticalIOs", self.TypeInt, "Ignore optical IOs in simulations (1=Ignore, 0=Include)", default = 0)
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    TECHNOLOGY = get_technology()
    ly = self.layout
    shapes = self.cell.shapes
    dbu = self.layout.dbu
    
    LayerINTERCONNECT = ly.layer(TECHNOLOGY['733_Lumerical'])

    # Draw the laser
    width = 60/dbu
    height = 40/dbu
    shapes(LayerINTERCONNECT).insert(pya.Box(-width/2, -height/2, width/2, height/2))
    
    shapes(LayerINTERCONNECT).insert(pya.Text("Tunable Laser", pya.Trans(pya.Trans.R0,-width/2+3/dbu, height/2-4/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(pya.Text("Wavelength range: %4.3f - %4.3f nm" % (self.wavelength_start, self.wavelength_stop), pya.Trans(pya.Trans.R0,-width/2+3/dbu, height/2-8/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(pya.Text ("Number of points: %s" % (self.npoints), pya.Trans(pya.Trans.R0,-width/2+3/dbu, height/2-12/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(pya.Text("Ignore optical IOs in simulations: %s" % (self.ignoreOpticalIOs), pya.Trans(pya.Trans.R0,-width/2+3/dbu, height/2-16/dbu))).text_size = 1.5/dbu
    # Add a polygon text description
    from SiEPIC.utils import layout_pgtext
    layout_pgtext(self.cell, _globals.TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+2, "Number of points: %s" % (self.npoints), 2.2)
    layout_pgtext(self.cell, _globals.TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+5, "Wavelength range: %4.3f - %4.3f nm" % (self.wavelength_start, self.wavelength_stop), 2.2)

class LumericalINTERCONNECT_Detector(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the LumericalINTERCONNECT Optical Network Analyzer.
  This configures the detector  
  """
  def __init__(self):
    # Important: initialize the super class
    super(LumericalINTERCONNECT_Detector, self).__init__()
    detector_number = 1
      
    # declare the parameters
    self.param("number", self.TypeInt, "Detector number", default = detector_number)     
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))

  def can_create_from_shape_impl(self):
    return False

  def coerce_parameters_impl(self):
    pass
           
  def produce_impl(self):
    TECHNOLOGY = get_technology()
    ly = self.layout
    shapes = self.cell.shapes
    dbu = self.layout.dbu
    
    LayerINTERCONNECT = ly.layer(TECHNOLOGY['733_Lumerical'])

    # Draw the outline
    width = 60/dbu
    height = 40/dbu
    shapes(LayerINTERCONNECT).insert(pya.Box(-width/2, -height/2, width/2, height/2))

    shapes(LayerINTERCONNECT).insert(pya.Text("Detector", pya.Trans(-width/2+3/dbu, height/2-4/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(pya.Text("Detector Number: %s" % (self.number), pya.Trans(-width/2+3/dbu, height/2-8/dbu))).text_size = 1.5/dbu
    shapes(LayerINTERCONNECT).insert(pya.Text("LumericalINTERCONNECT_Detector %s" % (self.number), pya.Trans(0,0))).text_size = 0.1/dbu

    # Add a polygon text description
    from SiEPIC.utils import layout_pgtext
    layout_pgtext(self.cell, _globals.TECHNOLOGY['Text'], -width/2*dbu+3, -height/2*dbu+2, "Number: %s" % (self.number), 2.2)

class Ring_Modulator_DB(pya.PCellDeclarationHelper):
  """
  The PCell declaration for ring modulator.
  Consists of a ring with 2 straight waveguides
  With pn junction and heater
  Written by Anthony Park and Wei Shi, 2017
  """
  def __init__(self):
    super(Ring_Modulator_DB, self).__init__()
    # declare the parameters
    TECHNOLOGY = get_technology()
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Si'])
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("gmon", self.TypeDouble, "Gap Monitor", default = 0.5)
    self.param("si3layer", self.TypeLayer, "SiEtch2(Rib) Layer", default = TECHNOLOGY['SiEtch2'])
    self.param("nlayer", self.TypeLayer, "N Layer", default = TECHNOLOGY['Si N'])
    self.param("player", self.TypeLayer, "P Layer", default = TECHNOLOGY['Si P'])
    self.param("nplayer", self.TypeLayer, "N+ Layer", default = TECHNOLOGY['Si N+'])
    self.param("pplayer", self.TypeLayer, "P+ Layer", default = TECHNOLOGY['Si P+'])
    self.param("npplayer", self.TypeLayer, "N++ Layer", default = TECHNOLOGY['Si N++'])
    self.param("ppplayer", self.TypeLayer, "P++ Layer", default = TECHNOLOGY['Si P++'])
    self.param("vclayer", self.TypeLayer, "VC Layer", default = TECHNOLOGY['VC'])
    self.param("m1layer", self.TypeLayer, "M1 Layer", default = TECHNOLOGY['M1'])
    self.param("vllayer", self.TypeLayer, "VL Layer", default = TECHNOLOGY['VL'])
    self.param("mllayer", self.TypeLayer, "ML Layer", default = TECHNOLOGY['Si'])
    self.param("mhlayer", self.TypeLayer, "MH Layer", default = TECHNOLOGY['M Heater'])
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textl", self.TypeLayer, "Text Layer", default = TECHNOLOGY['Text'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Ring_Modulator_DB(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout
    from math import pi, cos, sin
    
    # fetch the parameters
    TECHNOLOGY = get_technology()
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSi3 = ly.layer(self.si3layer)
    LayerSiN = ly.layer(LayerSi)
    LayernN = ly.layer(self.nlayer)
    LayerpN = ly.layer(self.player)
    LayernpN = ly.layer(self.nplayer)
    LayerppN = ly.layer(self.pplayer)
    LayernppN = ly.layer(self.npplayer)
    LayerpppN = ly.layer(self.ppplayer)
    LayervcN = ly.layer(self.vclayer)
    Layerm1N = ly.layer(self.m1layer)
    LayervlN = ly.layer(self.vllayer)
    LayermlN = ly.layer(self.mllayer)
    LayermhN = ly.layer(self.mhlayer)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    
    # Define variables for the Modulator
    # Variables for the Si waveguide
    w = self.w/dbu
    r = self.r/dbu
    g = self.g/dbu
    gmon = self.gmon/dbu
    
    #Variables for the N layer
    w_1 = 2.0/dbu  #same for N, P, N+, P+ layer
    r_n = (self.r - 1.0)/dbu
    
    #Variables for the P layer
    r_p = (self.r + 1.0)/dbu
     
    #Variables for the N+layer
    r_np = (self.r - 1.5)/dbu
    
    #Variables for the P+layer
    r_pp = (self.r + 1.5)/dbu

    #Variables for the N++ layer
    w_2 = 5.5/dbu  #same for N++, P++ layer
    r_npp = (self.r - 3.75)/dbu

    #Variables for the P+layer
    r_ppp = (self.r + 3.75)/dbu

    #Variables for the VC layer
    w_vc = 4.0/dbu
    r_vc1 = (self.r - 3.75)/dbu
    r_vc2 = (self.r + 3.75)/dbu
   
    #Variables for the M1 layer
    w_m1_in = (r_vc1 + w_vc/2.0 + 0.5/dbu)
    r_m1_in = (r_vc1 + w_vc/2.0 + 0.5/dbu) /2.0
    w_m1_out = 6.0/dbu
    r_m1_out = (self.r + 4.25)/dbu
    
    #Variables for the VL layer
    #r_vl =  w_m1_in/2.0 -  2.1/dbu
    r_vl =  r_vc1 - w_vc/2.0 - 2.01/dbu
    if r_vl &lt; 1.42/dbu:
      r_vl = 1.42/dbu
      w_vc = (self.r-1.75)/dbu - (r_vl + 2.01)
      r_vc1 = (self.r-1.75)/dbu - w_vc/2.0
      r_vc2 = (self.r+1.75)/dbu + w_vc/2.0
      w_2 = (r-w/2.0 - 0.75/dbu) - (r_vc1 - w_vc/2.0 - 0.75) # same for N++, P++ layer
      r_npp = ((r-w/2.0 - 0.75/dbu) + (r_vc1 - w_vc/2.0 - 0.75))/2.0
      r_ppp = 2*(self.r)/dbu - r_npp
    w_via = 5.0/dbu
    h_via = 5.0/dbu

    # Variables for the SiEtch2 layer  (Slab)
    w_Si3 = w_m1_out + 2*(r_m1_out)+ 0/dbu
    h_Si3 = w_Si3
    taper_bigend =  2/dbu
    taper_smallend =  0.3/dbu
    taper_length =  5/dbu

    #Variables for the MH layer
    w_mh = 2.0/dbu
    r_mh = self.r/dbu
    r_mh_in = r_mh - w_mh/2.0
    
    #Define Ring centre   
    x0 = r + w/2
    y0 = r + g + w 

    ######################
    # Generate the layout:
   
    # Create the ring resonator
    t = pya.Trans(pya.Trans.R0,x0, y0)
    pcell = ly.create_cell("Ring", "SiEPIC GSiP Library", { "layer": TECHNOLOGY['Si'], "radius": self.r, "width": self.w } )
    self.cell.insert(pya.CellInstArray(pcell.cell_index(), t))
    
    # Create the two waveguides
    wg1 = pya.Box(x0 - (w_Si3 / 2 + taper_length), -w/2, x0 + (w_Si3 / 2 + taper_length), w/2)
    shapes(LayerSiN).insert(wg1)
    y_offset = 2*r + g + gmon + 2*w
    wg2 = pya.Box(x0 - (w_Si3 / 2 + taper_length), y_offset-w/2, x0 + (w_Si3 / 2 + taper_length), y_offset+w/2)
    shapes(LayerSiN).insert(wg2)

    
    #Create the SiEtch2 (Slab) layer
    boxSi3 = pya.Box(x0-w_Si3/2.0, y0 - h_Si3/2.0, x0+w_Si3/2.0, y0 + h_Si3/2.0)
    shapes(LayerSi3).insert(boxSi3)
    pin1pts = [pya.Point(x0-w_Si3/2.0, -taper_bigend/2.0),
               pya.Point(x0-w_Si3/2.0-taper_length,-taper_smallend/2.0),
               pya.Point(x0-w_Si3/2.0-taper_length,taper_smallend/2.0),
               pya.Point(x0-w_Si3/2.0, taper_bigend/2.0)]
    pin2pts = [pya.Point(x0+w_Si3/2.0,-taper_bigend/2.0),
               pya.Point(x0+w_Si3/2.0+taper_length,-taper_smallend/2.0),
               pya.Point(x0+w_Si3/2.0+taper_length,taper_smallend/2.0),
               pya.Point(x0+w_Si3/2.0,+taper_bigend/2.0)]
    pin3pts = [pya.Point(x0-w_Si3/2.0,y_offset-taper_bigend/2.0),
               pya.Point(x0-w_Si3/2.0-taper_length,y_offset-taper_smallend/2.0),
               pya.Point(x0-w_Si3/2.0-taper_length,y_offset+taper_smallend/2.0),
               pya.Point(x0-w_Si3/2.0,y_offset+ taper_bigend/2.0)]
    pin4pts = [pya.Point(x0+w_Si3/2.0,y_offset-taper_bigend/2.0),
               pya.Point(x0+w_Si3/2.0+taper_length,y_offset-taper_smallend/2.0),
               pya.Point(x0+w_Si3/2.0+taper_length,y_offset+taper_smallend/2.0),
               pya.Point(x0+w_Si3/2.0,y_offset+taper_bigend/2.0)]
    shapes(LayerSi3).insert(pya.Polygon(pin1pts))
    shapes(LayerSi3).insert(pya.Polygon(pin2pts))
    shapes(LayerSi3).insert(pya.Polygon(pin3pts))
    shapes(LayerSi3).insert(pya.Polygon(pin4pts))
    
    # arc angles
    # doping:
    angle_min_doping = -35
    angle_max_doping = 215
    # VC contact:
    angle_min_VC = angle_min_doping + 8
    angle_max_VC = angle_max_doping - 8
    # M1:
    angle_min_M1 = angle_min_VC - 4
    angle_max_M1 = angle_max_VC + 4
    # MH:
    angle_min_MH = -75.0
    angle_max_MH = 255

    from SiEPIC.utils import arc

    #Create the N Layer
    self.cell.shapes(LayernN).insert(pya.Path(arc(r_n, angle_min_doping, angle_max_doping), w_1).transformed(t).simple_polygon())

    #Create the P Layer
    self.cell.shapes(LayerpN).insert(pya.Path(arc(r_p, angle_min_doping, angle_max_doping), w_1).transformed(t).simple_polygon())
    
    #Create the N+ Layer
    self.cell.shapes(LayernpN).insert(pya.Path(arc(r_np, angle_min_doping, angle_max_doping), w_1).transformed(t).simple_polygon())

    #Create the P+ Layer
    self.cell.shapes(LayerppN).insert(pya.Path(arc(r_pp, angle_min_doping, angle_max_doping), w_1).transformed(t).simple_polygon())
    
    #Create the N++ Layer
    self.cell.shapes(LayernppN).insert(pya.Path(arc(r_npp, angle_min_doping, angle_max_doping), w_1).transformed(t).simple_polygon())

    #Create the P+ +Layer
    poly = pya.Path(arc(r_ppp, angle_min_doping, angle_max_doping), w_2).transformed(t).simple_polygon()
    self.cell.shapes(LayerpppN).insert(pya.Region(poly) - pya.Region(pya.Box(x0-r_ppp-w_2/2, y_offset-w/2 - 0.75/dbu, x0+r_ppp+w/2, y_offset+w/2 + 0.75/dbu)))
    
    #Create the VC Layer
    self.cell.shapes(LayervcN).insert(pya.Path(arc(r_vc1, angle_min_VC, angle_max_VC), w_vc).transformed(t).simple_polygon())

    poly = pya.Path(arc(r_vc2, angle_min_VC, angle_max_VC), w_vc).transformed(t).simple_polygon()
    self.cell.shapes(LayervcN).insert(pya.Region(poly) - pya.Region(pya.Box(x0-r_vc2-w_vc/2, y_offset-w/2 - 1.5/dbu, x0+r_vc2+w_vc/2, y_offset+w/2 + 1.5/dbu)))
    
    #Create the M1 Layer
    self.cell.shapes(Layerm1N).insert(pya.Polygon(arc(w_m1_in, angle_min_doping, angle_max_doping) + [pya.Point(-w_m1_in, w_m1_in)]).transformed(t))
    self.cell.shapes(Layerm1N).insert(pya.Polygon(arc(w_m1_in/2.0, 0, 360)).transformed(t))
    self.cell.shapes(Layerm1N).insert(pya.Path(arc(r_m1_out, angle_min_M1, angle_max_M1), w_m1_out).transformed(t).simple_polygon())

    boxM11 = pya.Box(x0-w_via, y0 + r_m1_out + w_m1_out-h_via, x0+w_via, y0 + r_m1_out + w_m1_out+h_via)
    shapes(Layerm1N).insert(boxM11)
    
    #Create the ML Layer
    self.cell.shapes(LayermlN).insert(pya.Polygon(arc(w_m1_in/2.0, 0, 360)).transformed(t))
    
    #Create the VL Layer, as well as the electrical PinRec geometries
    # centre contact (P, anode):
    self.cell.shapes(LayervlN).insert(pya.Polygon(arc(r_vl, 0, 360)).transformed(t))
    self.cell.shapes(LayerPinRecN).insert(pya.Polygon(arc(r_vl, 0, 360)).transformed(t))
    shapes(LayerPinRecN).insert(pya.Text ("elec1a", pya.Trans(x0,y0))).text_size = 0.5/dbu
    shapes(LayerPinRecN).insert(pya.Box(x0-w_via/2, y0-w_via/2, x0+w_via/2, y0+w_via/2))
    
    # top contact (N, cathode):
    boxVL1 = pya.Box(x0-w_via/2, y0 +  r_vc2 +  w_vc/2 + 2.0/dbu, x0+w_via/2, y0 + r_vc2 +  w_vc/2 + 2.0/dbu+ h_via)
    shapes(LayervlN).insert(boxVL1)
    shapes(LayerPinRecN).insert(boxVL1)
    shapes(LayerPinRecN).insert(pya.Text ("elec1c", pya.Trans(pya.Trans.R0,x0,y0 + r_vc2 +  w_vc/2 + 2.0/dbu+ h_via/2))).text_size = 0.5/dbu
    # heater contacts
    boxVL3 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi) + 2.5/dbu, -w/2.0 -  10/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + 7.5/dbu, -w/2.0 -  5/dbu)
    shapes(LayervlN).insert(boxVL3)
    shapes(LayerPinRecN).insert(boxVL3)
    shapes(LayerPinRecN).insert(pya.Text ("elec2h2", pya.Trans(pya.Trans.R0,x0+(r_mh_in)*cos(angle_min_MH/180*pi) + 5.0/dbu,-w/2.0 -  7.5/dbu))).text_size = 0.5/dbu
    boxVL4 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)- 7.5/dbu, -w/2.0 -  10/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi) - 2.5/dbu, -w/2.0 -  5/dbu)
    shapes(LayervlN).insert(boxVL4)
    shapes(LayerPinRecN).insert(boxVL4)
    shapes(LayerPinRecN).insert(pya.Text ("elec2h1", pya.Trans(pya.Trans.R0,x0-(r_mh_in)*cos(angle_min_MH/180*pi) - 5.0/dbu,-w/2.0 -  7.5/dbu))).text_size = 0.5/dbu

    #Create the MH Layer
    self.cell.shapes(LayermhN).insert(pya.Path(arc(r_mh, angle_min_MH, angle_max_MH), w_mh).transformed(t).simple_polygon())
    boxMH1 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  2.5/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + w_mh, y0 +(r_mh_in)*sin(angle_min_MH/180*pi))
    shapes(LayermhN).insert(boxMH1)
    boxMH2 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)  - w_mh, -w/2.0 -  2.5/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi), y0 +(r_mh_in)*sin(angle_min_MH/180*pi))
    shapes(LayermhN).insert(boxMH2)
    boxMH3 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  12.5/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + 10/dbu, -w/2.0 -  2.5/dbu)
    shapes(LayermhN).insert(boxMH3)
    boxMH4 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)- 10/dbu, -w/2.0 -  12.5/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  2.5/dbu)
    shapes(LayermhN).insert(boxMH4)
    
    # Create the pins, as short paths:
    pin_length = 200 # database units, = 0.2 microns
    
    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 - (w_Si3 / 2 + taper_length)- pin_length/2, 0),
                                          pya.Point(x0 - (w_Si3 / 2 + taper_length) + pin_length/2, 0)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt1", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), 0))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 + (w_Si3 / 2 + taper_length)-pin_length/2, 0),
                                pya.Point(x0 + (w_Si3 / 2 + taper_length) + pin_length/2, 0)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt2", pya.Trans(pya.Trans.R0,x0 + (w_Si3 / 2 + taper_length), 0))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 - (w_Si3 / 2 + taper_length)- pin_length/2, y_offset),
                                          pya.Point(x0 - (w_Si3 / 2 + taper_length)+ pin_length/2, y_offset)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt3", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), y_offset))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 + (w_Si3 / 2 + taper_length)-pin_length/2, y_offset),
                                          pya.Point(x0 + (w_Si3 / 2 + taper_length)+ pin_length/2, y_offset)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt4", pya.Trans(pya.Trans.R0,x0 + (w_Si3 / 2 + taper_length), y_offset))).text_size = 0.5/dbu

    # Create the device recognition layer
    shapes(LayerDevRecN).insert(pya.Box(x0 - (w_Si3 / 2 + taper_length), -w/2.0 -  12.5/dbu, x0 + (w_Si3 / 2 + taper_length), y0 + r_m1_out + w_m1_out+h_via ))

    # Compact model information
    shape = shapes(LayerDevRecN).insert(pya.Text('Lumerical_INTERCONNECT_library=Design kits/GSiP', \
      pya.Trans(pya.Trans.R0,0, 0))).text_size = 0.3/dbu
    shapes(LayerDevRecN).insert(pya.Text('Lumerical_INTERCONNECT_component=Ring_Modulator_DB', \
      pya.Trans(pya.Trans.R0,0, w*2))).text_size = 0.3/dbu
    shapes(LayerDevRecN).insert(pya.Text \
      ('Spice_param:radius=%.3fu wg_width=%.3fu gap=%.3fu gap_monitor=%.3fu' %\
      (self.r, self.w, self.g, self.gmon), \
      pya.Trans(pya.Trans.R0,0, -w*2) ) ).text_size = 0.3/dbu
    
    # Add a polygon text description
    from SiEPIC.utils import layout_pgtext
    if self.textpolygon : layout_pgtext(self.cell, self.textl, self.w, self.r+self.w, "%.3f-%g" % ( self.r, self.g), 1)

    # Reference publication:
    shapes(TextLayerN).insert(pya.Text ("Ref: Raphael Dube-Demers, JLT, 2015", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), -w/2.0 -  12.5/dbu+4.0/dbu))).text_size = 0.7/dbu
    shapes(TextLayerN).insert(pya.Text ("http://dx.doi.org/10.1109/JLT.2015.2462804", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), -w/2.0 -  12.5/dbu+1.0/dbu))).text_size = 0.7/dbu

class Ring_Filter_DB(pya.PCellDeclarationHelper):
  """
  The PCell declaration for thermally tunable ring filter.
  """
  def __init__(self):
    super(Ring_Filter_DB, self).__init__()
    # declare the parameters
    TECHNOLOGY = get_technology()
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Si'])
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("gmon", self.TypeDouble, "Gap Monitor", default = 0.5)
    self.param("si3layer", self.TypeLayer, "SiEtch2(Rib) Layer", default = TECHNOLOGY['SiEtch2'])
    self.param("vllayer", self.TypeLayer, "VL Layer", default = TECHNOLOGY['VL'])
    self.param("mllayer", self.TypeLayer, "ML Layer", default = TECHNOLOGY['ML'])
    self.param("mhlayer", self.TypeLayer, "MH Layer", default = TECHNOLOGY['M Heater'])
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textl", self.TypeLayer, "Text Layer", default = TECHNOLOGY['Text'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Ring_Filter_DB(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout
    from math import pi, cos, sin
    
    # fetch the parameters
    TECHNOLOGY = get_technology()
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSi3 = ly.layer(self.si3layer)
    LayerSiN = ly.layer(LayerSi)
    LayervlN = ly.layer(self.vllayer)
    LayermlN = ly.layer(self.mllayer)
    LayermhN = ly.layer(self.mhlayer)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    
    # Define variables for the Modulator
    # Variables for the Si waveguide
    w = self.w/dbu
    r = self.r/dbu
    g = self.g/dbu
    gmon = self.gmon/dbu
    
    #Variables for the N layer
    w_1 = 2.0/dbu  #same for N, P, N+, P+ layer
    r_n = (self.r - 1.0)/dbu

    #Variables for the VC layer
    w_vc = 4.0/dbu
    r_vc1 = (self.r - 3.75)/dbu
    r_vc2 = (self.r + 3.75)/dbu
   
    #Variables for the M1 layer
    w_m1_in = (r_vc1 + w_vc/2.0 + 0.5/dbu)
    r_m1_in = (r_vc1 + w_vc/2.0 + 0.5/dbu) /2.0
    w_m1_out = 6.0/dbu
    r_m1_out = (self.r + 4.25)/dbu
    
    #Variables for the VL layer
    r_vl =  w_m1_in/2.0 -  2.1/dbu
    w_via = 5.0/dbu
    h_via = 5.0/dbu

    # Variables for the SiEtch2 layer  (Slab)
    w_Si3 = w_m1_out + 2*(r_m1_out)+ 0/dbu
    h_Si3 = w_Si3
    taper_bigend =  2/dbu
    taper_smallend =  0.3/dbu
    taper_length =  5/dbu

    #Variables for the MH layer
    w_mh = 2.0/dbu
    r_mh = self.r/dbu
    r_mh_in = r_mh - w_mh/2.0
    
    #Define Ring centre   
    x0 = r + w/2
    y0 = r + g + w 

    ######################
    # Generate the layout:
   
    # Create the ring resonator
    t = pya.Trans(pya.Trans.R0,(self.r+self.w/2)/dbu, (self.r+self.g+self.w)/dbu)
    pcell = ly.create_cell("Ring", "SiEPIC GSiP Library", { "layer": TECHNOLOGY['Si'], "radius": self.r, "width": self.w } )
    self.cell.insert(pya.CellInstArray(pcell.cell_index(), t))
    
    # Create the two waveguides
    wg1 = pya.Box(x0 - (w_Si3 / 2 + taper_length), -w/2, x0 + (w_Si3 / 2 + taper_length), w/2)
    shapes(LayerSiN).insert(wg1)
    y_offset = 2*r + g + gmon + 2*w
    wg2 = pya.Box(x0 - (w_Si3 / 2 + taper_length), y_offset-w/2, x0 + (w_Si3 / 2 + taper_length), y_offset+w/2)
    shapes(LayerSiN).insert(wg2)
    
    #Create the SiEtch2 (Slab) layer
    boxSi3 = pya.Box(x0-w_Si3/2.0, y0 - h_Si3/2.0, x0+w_Si3/2.0, y0 + h_Si3/2.0)
    shapes(LayerSi3).insert(boxSi3)
    pin1pts = [pya.Point(x0-w_Si3/2.0,-taper_bigend/2.0), pya.Point(x0-w_Si3/2.0-taper_length,-taper_smallend/2.0), pya.Point(x0-w_Si3/2.0-taper_length,taper_smallend/2.0), pya.Point(x0-w_Si3/2.0, taper_bigend/2.0)]
    pin2pts = [pya.Point(x0+w_Si3/2.0,-taper_bigend/2.0), pya.Point(x0+w_Si3/2.0+taper_length,-taper_smallend/2.0), pya.Point(x0+w_Si3/2.0+taper_length,taper_smallend/2.0), pya.Point(x0+w_Si3/2.0,+taper_bigend/2.0)]
    pin3pts = [pya.Point(x0-w_Si3/2.0,y_offset-taper_bigend/2.0), pya.Point(x0-w_Si3/2.0-taper_length,y_offset-taper_smallend/2.0), pya.Point(x0-w_Si3/2.0-taper_length,y_offset+taper_smallend/2.0),pya. Point(x0-w_Si3/2.0,y_offset+ taper_bigend/2.0)]
    pin4pts = [pya.Point(x0+w_Si3/2.0,y_offset-taper_bigend/2.0), pya.Point(x0+w_Si3/2.0+taper_length,y_offset-taper_smallend/2.0), pya.Point(x0+w_Si3/2.0+taper_length,y_offset+taper_smallend/2.0), pya.Point(x0+w_Si3/2.0,y_offset+taper_bigend/2.0)]
    shapes(LayerSi3).insert(pya.Polygon(pin1pts))
    shapes(LayerSi3).insert(pya.Polygon(pin2pts))
    shapes(LayerSi3).insert(pya.Polygon(pin3pts))
    shapes(LayerSi3).insert(pya.Polygon(pin4pts))
    
    from SiEPIC.utils import arc
    
    # arc angles
    # doping:
    angle_min_doping = -35
    angle_max_doping = 215
    # VC contact:
    angle_min_VC = angle_min_doping + 8
    angle_max_VC = angle_max_doping - 8
    # M1:
    angle_min_M1 = angle_min_VC - 4
    angle_max_M1 = angle_max_VC + 4
    # MH:
    angle_min_MH = -75.0
    angle_max_MH = 255
    
    #Create the VL Layer, as well as the electrical PinRec geometries
    # heater contacts
    boxVL3 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi) + 2.5/dbu, -w/2.0 -  10/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + 7.5/dbu, -w/2.0 -  5/dbu)
    shapes(LayervlN).insert(boxVL3)
    shapes(LayerPinRecN).insert(boxVL3)
    shapes(LayerPinRecN).insert(pya.Text ("elec2h2", pya.Trans(pya.Trans.R0,x0+(r_mh_in)*cos(angle_min_MH/180*pi) + 5.0/dbu,-w/2.0 -  7.5/dbu))).text_size = 0.5/dbu
    boxVL4 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)- 7.5/dbu, -w/2.0 -  10/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi) - 2.5/dbu, -w/2.0 -  5/dbu)
    shapes(LayervlN).insert(boxVL4)
    shapes(LayerPinRecN).insert(boxVL4)
    shapes(LayerPinRecN).insert(pya.Text ("elec2h1", pya.Trans(pya.Trans.R0,x0-(r_mh_in)*cos(angle_min_MH/180*pi) - 5.0/dbu,-w/2.0 -  7.5/dbu))).text_size = 0.5/dbu

    #Create the MH Layer
    poly = pya.Path(arc(self.r/dbu, angle_min_MH, angle_max_MH), w_mh).transformed(t).simple_polygon()
    self.cell.shapes(LayermhN).insert(poly)
    boxMH1 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  2.5/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + w_mh, y0 +(r_mh_in)*sin(angle_min_MH/180*pi))
    shapes(LayermhN).insert(boxMH1)
    boxMH2 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)  - w_mh, -w/2.0 -  2.5/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi), y0 +(r_mh_in)*sin(angle_min_MH/180*pi))
    shapes(LayermhN).insert(boxMH2)
    boxMH3 = pya.Box(x0+(r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  12.5/dbu, x0 + (r_mh_in)*cos(angle_min_MH/180*pi) + 10/dbu, -w/2.0 -  2.5/dbu)
    shapes(LayermhN).insert(boxMH3)
    boxMH4 = pya.Box(x0-(r_mh_in)*cos(angle_min_MH/180*pi)- 10/dbu, -w/2.0 -  12.5/dbu, x0 - (r_mh_in)*cos(angle_min_MH/180*pi), -w/2.0 -  2.5/dbu)
    shapes(LayermhN).insert(boxMH4)
    
    # Create the pins, as short paths:
    pin_length = 200 # database units, = 0.2 microns
    
    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 - (w_Si3 / 2 + taper_length)- pin_length/2, 0),
                                          pya.Point(x0 - (w_Si3 / 2 + taper_length) + pin_length/2, 0)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt1", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), 0))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 + (w_Si3 / 2 + taper_length)-pin_length/2, 0),
                                          pya.Point(x0 + (w_Si3 / 2 + taper_length) + pin_length/2, 0)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt2", pya.Trans(pya.Trans.R0,x0 + (w_Si3 / 2 + taper_length), 0))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 - (w_Si3 / 2 + taper_length)- pin_length/2, y_offset),
                                          pya.Point(x0 - (w_Si3 / 2 + taper_length)+ pin_length/2, y_offset)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt3", pya.Trans(pya.Trans.R0,x0 - (w_Si3 / 2 + taper_length), y_offset))).text_size = 0.5/dbu

    shapes(LayerPinRecN).insert(pya.Path([pya.Point(x0 + (w_Si3 / 2 + taper_length)-pin_length/2, y_offset),
                                          pya.Point(x0 + (w_Si3 / 2 + taper_length)+ pin_length/2, y_offset)], w))
    shapes(LayerPinRecN).insert(pya.Text("opt4", pya.Trans(pya.Trans.R0,x0 + (w_Si3 / 2 + taper_length), y_offset))).text_size = 0.5/dbu

    # Create the device recognition layer
    shapes(LayerDevRecN).insert(pya.Box(x0 - (w_Si3 / 2 + taper_length), -w/2.0 -  12.5/dbu, x0 + (w_Si3 / 2 + taper_length), y0 + r_m1_out + w_m1_out+h_via ))

    # Compact model information
    shape = shapes(LayerDevRecN).insert(pya.Text('Lumerical_INTERCONNECT_library=Design kits/GSiP', \
      pya.Trans(pya.Trans.R0,0, 0))).text_size = 0.3/dbu
    shapes(LayerDevRecN).insert(pya.Text ('Lumerical_INTERCONNECT_component=Ring_Filter_DB', \
      pya.Trans(pya.Trans.R0,0, w*2))).text_size = 0.3/dbu
    shapes(LayerDevRecN).insert(pya.Text \
      ('Spice_param:radius=%.3fu wg_width=%.3fu gap=%.3fu gap_monitor=%.3fu' %\
      (self.r, self.w, self.g, self.gmon), \
      pya.Trans(pya.Trans.R0,0, -w*2) ) ).text_size = 0.3/dbu
    
    # Add a polygon text description
    from SiEPIC.utils import layout_pgtext
    if self.textpolygon:
      layout_pgtext(self.cell, self.textl, self.w, self.r+self.w, "%.3f-%g" % ( self.r, self.g), 1)

class GSiP(pya.Library):
  def __init__(self):
    print("Initializing SiEPIC GSiP Library.")

    self.description = ""

    #import os
    #self.layout().read(os.path.join(os.path.dirname(os.path.realpath(__file__)), "SiEPIC-GSiP.gds"))
    #[self.layout().rename_cell(i, self.layout().cell_name(i).replace('_', ' ')) for i in range(0, self.layout().cells())]
    
    self.layout().register_pcell("Lumerical INTERCONNECT Laser", LumericalINTERCONNECT_Laser())
    self.layout().register_pcell("Lumerical INTERCONNECT Detector", LumericalINTERCONNECT_Detector())
    self.layout().register_pcell("Waveguide", Waveguide())
    self.layout().register_pcell("Ring", Ring())
    self.layout().register_pcell("Double-bus Ring Modulator", Ring_Modulator_DB())
    self.layout().register_pcell("Double-bus Ring Filter", Ring_Filter_DB())
    
    self.register("SiEPIC GSiP Library")
    
GSiP()
 </text>
</klayout-macro>
